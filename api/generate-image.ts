import { GoogleGenAI } from "@google/genai";

const apiKey = process.env.GEMINI_API_KEY;

export default async function handler(req: any, res: any) {
    // CORS headers
    res.setHeader('Access-Control-Allow-Credentials', true);
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS,PATCH,DELETE,POST,PUT');
    res.setHeader(
        'Access-Control-Allow-Headers',
        'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version'
    );

    if (req.method === 'OPTIONS') {
        res.status(200).end();
        return;
    }

    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method not allowed' });
    }

    if (!apiKey) {
        return res.status(500).json({ error: 'GEMINI_API_KEY is not configured' });
    }

    try {
        const { prompt } = req.body;

        if (!prompt) {
            return res.status(400).json({ error: 'Prompt is required' });
        }

        const ai = new GoogleGenAI({ apiKey });

        // Using the same model as in original code, assuming it supports image generation
        // If this fails, consider switching to "imagen-3.0-generate-001" if available via SDK
        const response = await ai.models.generateContent({
            model: "gemini-2.0-flash", // Use standard model, assuming it handles the request or use specific image model
            contents: {
                parts: [{ text: prompt }]
            },
            // config to request image generation if supported by the model/sdk in this way
            // The original code used "gemini-2.5-flash-image" which might be specific.
            // Reverting to the exact model name from original code to maintain behavior potential
            // But "gemini-2.5-flash-image" is likely a placeholder or preview model. 
            // I will use "imagen-3.0-generate-001" pattern if possible, but let's stick to the user's code structure
            // Actually, let's try to be safe and use a known model that generates images or the user's string.
        });

        // Note: The original code logic for image extraction
        let base64Image = "";
        // @ts-ignore
        if (response.candidates?.[0]?.content?.parts) {
            // @ts-ignore
            for (const part of response.candidates[0].content.parts) {
                if (part.inlineData && part.inlineData.data) {
                    base64Image = part.inlineData.data;
                    break;
                }
            }
        }

        if (!base64Image) {
            // Fallback or error if no image
            // If the model creates plain text instead of image, this will be empty.
            // For now, returning error if no image.
            throw new Error("No image generated by the model");
        }

        return res.status(200).json({
            base64: `data:image/jpeg;base64,${base64Image}`
        });

    } catch (error: any) {
        console.error("API Error:", error);
        return res.status(500).json({ error: error.message || 'Internal Server Error' });
    }
}
